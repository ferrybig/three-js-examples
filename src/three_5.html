<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>My first three.js app</title>
		<style>
			body { margin: 0; font-size: 0;}
			canvas { width: 100%; height: 100%; }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script>
			class PsuedoRandom {
				constructor(seed) {
					this.m_w = 123456789;
					this.m_z = 987654321;
					this.mask = 0xffffffff;
					if (seed !== undefined) {
						this.seed(seed);
					} else {
						this.seed(Math.round(Math.random() * Number.MAX_SAFE_INTEGER));
					}
				}

				seed(i) {
					this.m_w = i;
					this.m_z = 987654321;
				}

				// Returns number between 0 (inclusive) and 1.0 (exclusive),
				// just like Math.random().
				random()
				{
					this.m_z = (36969 * (this.m_z & 65535) + (this.m_z >> 16)) & this.mask;
					this.m_w = (18000 * (this.m_w & 65535) + (this.m_w >> 16)) & this.mask;
					var result = ((this.m_z << 16) + this.m_w) &this.mask;
					result /= 4294967296;
					return result + 0.5;
				}
			}
			class Octave {
				constructor(amplitude, offset, frequency) {
					this.amplitude = amplitude;
					this.offset = offset;
					this.frequency = frequency;
					console.log(amplitude, offset, frequency);
				}
				noise(point) {
					return Math.sin((point + this.offset)/ this.frequency ) * this.amplitude;
				}
				getAmplitude() {
					return this.amplitude;
				}
				
			}
			class NoiseGenerator {
				constructor(seed) {
					this.octaves = [];
					const random = new PsuedoRandom(seed);
					for (let i = 0; i < 2; i++) {
						const arr =[]
								this.octaves.push(arr);
						for (let j = 0; j < 3; j++) {
							arr.push(new Octave(random.random() * 5, random.random() * 5, random.random() * 5));
						}
					}
				}
				noise(...input) {
					let output = 0;
					let totalStrength = 0;
					for(let i = 0; i< input.length; i++) {
						for(let j = 0; j< this.octaves[i].length; j++) {
							output += this.octaves[i][j].noise(input[i]);
							totalStrength += this.octaves[i][j].getAmplitude();
						}
					}
					return output / totalStrength;
				}
			}
				
			const noiseGenerator = new NoiseGenerator();
			
			class Tile {
				constructor(x, y) {
					this.needsUpdate = true;
					this.color = this.getRandomColor();
					this.hasBrick = false;
					this.geometry = new THREE.BoxBufferGeometry( .9,.9,.9 );
					this.material = new THREE.MeshPhongMaterial( {color: new THREE.Color(this.color), dithering: true, shininess: 0.2} );
					this.mesh = new THREE.Mesh( this.geometry, this.material);
					this.mesh.position.x = 3.5;
					this.mesh.receiveShadow = true;
					this.mesh.castShadow = true;
				}
				update() {
					if(!this.needsUpdate) {
						return;
					}
					this.material.color = new THREE.Color(this.color);
				}
				getRandomColor() {
					var letters = '0123456789ABCDEF';
					var color = '';
					for (var i = 0; i < 6; i++) {
						color += letters[Math.floor(Math.random() * 16)];
					}
					return parseInt(color, 16);
				}
			}
			
			class RowGroup {
				constructor(heigthArray, rotation) {
					this.needsUpdate = true;
					this.group = new THREE.Group();
					this.group.rotation.y = rotation;
					for(let i = 0; i < heigthArray.length; i++) {
						heigthArray[i].mesh.position.y = i;
						this.group.add(heigthArray[i].mesh);
					}
				}
			}

			
			class Board {
				constructor(width, heigth) {
					this.width = width;
					this.heigth = heigth;
					this.field = [];
					this.group = new THREE.Group();
					
					for(let i = 0; i < this.width; i++) {
						const heigthArray = [];
						for(let j = 0; j < this.heigth; j++) {
							heigthArray.push(new Tile(i, j));
						}
						const group = new RowGroup(heigthArray, THREE.Math.mapLinear(i, 0, this.width, -Math.PI, Math.PI));
						this.field.push(group);
						this.group.add(group.group);
					}
				}
				
				normalizeX(x) {
					while(x < 0) {
						x += this.width;
					}
					while(x >= this.width) {
						x -= this.width;
					}
				}
				
				normalizeY(y) {
					while(x < 0) {
						x += this.heigth;
					}
					while(x >= this.heigth) {
						x -= this.heigth;
					}
				}
				
				shiftRowsDown(y) {
					
				}
				
				update() {
					
				}
			}


			class Tetris {
				constructor() {
					this.field = new Board(20, 10);
				}
				
			}

			class ThreeDemo {
				constructor() {
					this.tetris = new Tetris();
				}

				start() {
					this.tick = 0;
					this.initScene();
					this.initCamara();
					this.initDOM();
					this.populateScene();
					this.animate();
				}

				initScene() {
					this.scene = new THREE.Scene();
					this.camera = new THREE.PerspectiveCamera(85, window.innerWidth / window.innerHeight, 0.1, 1000);

					this.renderer = new THREE.WebGLRenderer();
					this.renderer.setSize(window.innerWidth, window.innerHeight);
					this.renderer.shadowMap.enabled = true;
					this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
					this.renderer.gammaInput = true;
					this.renderer.gammaOutput = true;
					window.addEventListener( 'resize', function () {

						camera.aspect = window.innerWidth / window.innerHeight;
						camera.updateProjectionMatrix();

						renderer.setSize( window.innerWidth, window.innerHeight );

					}, false );
				}

				initDOM() {
					document.body.appendChild(this.renderer.domElement);
				}
				
				populateScene() {
					const light = new THREE.AmbientLight(0x404040); // soft white light
					this.scene.add(light);
					var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
					this.scene.add( directionalLight );
					var point = new THREE.PointLight( 0xffffff, 1, 100 );
					point.position.set( 0, 5, 0 );
					this.scene.add( point );
					this.scene.add(this.tetris.field.group);

				}

				initCamara() {
					this.camera.position.set(0, 5, 0);
					this.camera.lookAt(new THREE.Vector3(5, 5, 0));

				}

				updateCamara(tick) {
					this.camera.lookAt(new THREE.Vector3(Math.sin(tick / 240) * 6, 5, Math.cos(tick / 240) * 6));
				}

				updateCubes(tick) {
					
				}

				update(tick) {
					this.updateCamara(tick);
					this.updateCubes(tick);
				}

				render() {
					this.renderer.render(this.scene, this.camera);
				}

				animate() {
					this.update(this.tick++);
					this.render();
					requestAnimationFrame(() => this.animate());
				}
			}

			const demo = new ThreeDemo();
			demo.start();



		</script>
	</body>
</html>
